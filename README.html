<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Algorithmic conversion with surjective pairing</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="pandoc.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Algorithmic conversion with surjective pairing</h1>
</header>
<p>This repository contains the Rocq mechanization of the results from
the paper "Algorithmic Conversion with Surjective Pairing: A Syntactic
and Untyped Approach".</p>
<p>While the documentation is written in <code
class="verbatim">org</code> mode, it is recommended that you use the
generated <code class="verbatim">README.html</code> file so you can
access the hyperlinks into the generated coqdoc files to navigate the
development in your web browser.</p>
<p>As mentioned in the paper, while the natural numbers are omitted from
the text, they can be found in the mechanization.</p>
<h2 id="quick-start">Quick start</h2>
<h3 id="installing-dependencies">Installing dependencies</h3>
<p>You can skip this section if you are compiling the proof scripts from
the configured VM.</p>
<p>Inside a fresh <code class="verbatim">opam</code> switch, run the
following commands to install the required dependencies.</p>
<div class="sourceCode" id="cb1" data-org-language="sh"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">opam</span> update</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">opam</span> install <span class="at">-y</span> coq-hammer-tactics coq-equations coq-stdpp coq-autosubst-ocaml</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="bu">eval</span> <span class="va">$(</span><span class="ex">opam</span> env<span class="va">)</span></span></code></pre></div>
<p>The termination proof can be brittle because we expect the <code
class="verbatim">inversion</code> to produce the subproofs of the domain
relation that make the termination checker happy.</p>
<p>Here are the versions of the Rocq packages that are known to
work.</p>
<ul>
<li>coq 8.20.1</li>
<li>coq-stdpp 1.11.0</li>
<li>coq-hammer-tactics 1.3.2</li>
<li>coq-autosubst-ocaml 1.1</li>
</ul>
<p>Note that if you don't plan to modify and regenerate the <code
class="verbatim">syntax.v</code> file from <code
class="verbatim">syntax.sig</code> using <code
class="verbatim">autosubst</code>, you can choose not to install <code
class="verbatim">coq-autosubst-ocaml</code>. However, you need to be
careful not to accidentally run <code
class="verbatim">make deepclean</code>, which will delete the
auto-generated syntax files. Instead, run <code class="verbatim">make
clean</code> if you want to keep the auto-generated files.</p>
<h3 id="validating-the-proofs">Validating the proofs</h3>
<p>After the dependencies are installed, run the following command to
validate the proof development. The <code class="verbatim">-j2</code>
flag allows <code class="verbatim">make</code> to validate up to 2 files
in parallel. According to our testing, going beyond <code
class="verbatim">-j2</code> does not reduce the compilation time.</p>
<div class="sourceCode" id="cb2" data-org-language="sh"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">make</span> <span class="at">-j2</span></span></code></pre></div>
<p>It is expected that the compilation process will generate a lot of
warnings about notations and the ssreflect library. The compilation is
successful as long as the command terminates with the following
output.</p>
<div class="sourceCode" id="cb3" data-org-language="sh"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ... lots of warnings ...</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="va">make</span><span class="op">[</span><span class="dv">1</span><span class="op">]</span><span class="ex">:</span> Leaving directory <span class="st">&#39;****&#39;</span></span></code></pre></div>
<p>On a Linux laptop with an Intel 12700k, the compilation takes 67
seconds. If you are running the command inside the attached VM and your
host device has an ARM CPU (e.g. Mac M-series), then it'll take around
10x longer since emulating x86 instructions can be quite slow.</p>
<h2 id="definitions">Definitions</h2>
<h3 id="grammar-fig.-1">Grammar (Fig. 1)</h3>
<ul>
<li>Terms: <a
href="html/DecSyn.Autosubst2.syntax.html#Core.PTm">PTm</a></li>
<li>Typing context: defined directly as <code
class="verbatim">list PTm</code></li>
</ul>
<p>The grammar specification in higher-order abstract syntax (HOAS) can
be found in <a href="./syntax.sig">syntax.sig</a>. We use the
autosubst-ocaml tool to turn the syntax file into the Rocq file <a
href="./theories/Autosubst2/syntax.v">syntax.v</a>, which contains not
only the de Bruijn grammar but also definitions of renaming and
substitution functions and their associated lemmas.</p>
<h3 id="typing-specification-fig.-2-3">Typing specification (Fig. 2,
3)</h3>
<ul>
<li>Typing: <a href="./html/DecSyn.typing.html#Wt">Wt</a> (<span
class="math inline"><em>Γ</em> ⊢ <em>a</em> ∈ <em>A</em></span>)</li>
<li>Equality: <a href="./html/DecSyn.typing.html#Eq">Eq</a> (<span
class="math inline"><em>Γ</em> ⊢ <em>a</em> ≡ <em>b</em> ∈ <em>A</em></span>)</li>
<li>Subtyping: <a href="./html/DecSyn.typing.html#LEq">LEq</a> (<span
class="math inline"><em>Γ</em> ⊢ <em>A</em> ≲ <em>B</em></span>)</li>
<li>Context well-formedness: <a
href="./html/DecSyn.typing.html#Wff">Wff</a> (<span
class="math inline"> ⊢ <em>Γ</em></span>)</li>
</ul>
<h3 id="untyped-relations-and-naming-schemes">Untyped relations and
naming schemes</h3>
<p>Due to the many reduction relations used in our proof, we organize
each untyped reduction, equality, and subtyping relation inside its own
module, where the relation itself is simply named <code
class="verbatim">R</code>. Thus, to avoid ambiguity, those modules are
never meant to be imported and the relation should always be referred to
in its qualified form. For example, the <span
class="math inline"><em>β</em></span>-reduction relation is defined as
the inductive type <a href="./html/DecSyn.fp_red.html#RRed.R">R</a> in
the module <a href="./html/DecSyn.fp_red.html#RRed">RRed</a>. Outside
the module, the <span class="math inline"><em>β</em></span>-reduction
relation is referred to by its fully qualified name <code
class="verbatim">RRed.R</code>.</p>
<p>Given a module containing a reduction relation named <code
class="verbatim">Red</code>, the module <code
class="verbatim">Reds</code> contains the properties about its reflexive
and transitive closure. Instead of defining the transitive and reflexive
closure of <code class="verbatim">Red.R</code> as <code
class="verbatim">RReds.R</code>, we directly refer to it as <code
class="verbatim">rtc
RRed.R</code>, where <code class="verbatim">rtc</code> is a relation
operator that outputs the reflexive and transitive closure of its
input.</p>
<p>Some relations are standard and therefore not included in the text
for concision, but we include them here for completeness.</p>
<ol>
<li><p>Normal form predicates (Fig. 5)</p>
<ul>
<li>normal forms (nf): <a
href="./html/DecSyn.fp_red.html#nf">nf</a></li>
<li>neutral forms (nf): <a
href="./html/DecSyn.fp_red.html#ne">ne</a></li>
<li>canonical forms (canf): <a
href="./html/DecSyn.common.html#ishf">ishf</a></li>
<li>weak-head neutral forms (whne): <a
href="./html/DecSyn.common.html#ishne">ishne</a></li>
<li>weak-head normal forms (whnf): inlined as the union of <code
class="verbatim">ishf</code> and <code
class="verbatim">ishne</code></li>
</ul>
<p>Note that we sometimes use <a
href="./html/DecSyn.common.html#HRed.nf">HRed.nf</a> in place of the
above definition of whnf, where the former means the term would no
longer reduce with weak-head reduction. These two definitions coincide
for precisely the set of terms that are non-stuck.</p>
<p>Also, instead of defining <a
href="./html/DecSyn.fp_red.html#nf">nf</a> and <a
href="./html/DecSyn.fp_red.html#ne">ne</a> as inductive predicates, we
define them as mutually recursive fixpoints. For the definition to be
accepted by the termination checker, the injection from ne to nf is
proven a posteriori as the lemma <a
href="./html/DecSyn.fp_red.html#ne_nf">ne_nf</a>.</p></li>
<li><p>Reductions</p>
<ul>
<li><span class="math inline"><em>β</em></span>-reduction (<span
class="math inline">⤳<sub><em>β</em></sub></span>): <a
href="./html/DecSyn.fp_red.html#RRed">RRed</a></li>
<li><span class="math inline"><em>η</em></span>-reduction (<span
class="math inline">⤳<sub><em>η</em></sub></span>): <a
href="./html/DecSyn.fp_red.html#ERed">ERed</a></li>
<li>parallel <span class="math inline"><em>β</em></span>-reduction
(<span class="math inline">⇒<sub><em>β</em></sub></span>): <a
href="./html/DecSyn.fp_red.html#RPar">RPar</a></li>
<li>parallel <span class="math inline"><em>η</em></span>-reduction
(<span class="math inline">⇒<sub><em>η</em></sub></span>): <a
href="./html/DecSyn.fp_red.html#EPar">EPar</a></li>
<li><span class="math inline"><em>β</em><em>η</em></span>-reduction
(<span class="math inline">⤳<sub><em>β</em><em>η</em></sub></span>): <a
href="./html/DecSyn.fp_red.html#RERed">RERed</a></li>
<li>leftmost-outermost <span
class="math inline"><em>β</em></span>-reduction (<span
class="math inline">⤳<sub><em>β</em></sub></span>): <a
href="./html/DecSyn.fp_red.html#LoRed">LoRed</a></li>
<li>weak-head <span class="math inline"><em>β</em></span>-reduction: <a
href="./html/DecSyn.common.html#HRed">HRed</a></li>
<li>restrictive parallel <span
class="math inline"><em>η</em></span>-reductions (<span
class="math inline">⇒<sub><em>r</em></sub></span>, <span
class="math inline">⇒<sub><em>r̄</em></sub></span>): <a
href="./html/DecSyn.fp_red.html#NeEPar">NeEPar</a></li>
</ul></li>
<li><p>Strong normalization (Sec. 3.2)</p>
<ul>
<li>Strong normal forms: <a
href="./html/DecSyn.fp_red.html#SN">SN</a></li>
<li>Strong neutral forms: <a
href="./html/DecSyn.fp_red.html#SNe">SNe</a></li>
<li>Strong weak head reduction: <a
href="./html/DecSyn.fp_red.html#TRedSN">TRedSN</a></li>
</ul></li>
<li><p>Joinability and Subtyping</p>
<ul>
<li><p>Joinability (w.r.t <span
class="math inline"><em>β</em><em>η</em></span>-reduction, Def. 3.1): <a
href="./html/DecSyn.fp_red.html#DJoin">DJoin</a></p></li>
<li><p>Joinability (w.r.t <span
class="math inline"><em>η</em></span>-reduction): <a
href="./html/DecSyn.fp_red.html#EJoin">EJoin</a></p></li>
<li><p>One-step subtyping (Page 12): <a
href="./html/DecSyn.fp_red.html#Sub1">Sub1</a></p></li>
<li><p>Untyped subtyping (Def. 3.2): <a
href="./html/DecSyn.fp_red.html#Sub">Sub</a></p></li>
<li><p>Untyped subtyping (w.r.t <span
class="math inline"><em>η</em></span>-reduction): <a
href="./html/DecSyn.fp_red.html#ESub">ESub</a></p></li>
</ul>
<p>Note that <a href="./html/DecSyn.fp_red.html#ESub">ESub</a> holds
when two terms can be related by one-step subtyping after <span
class="math inline"><em>η</em></span>-reduction. It is not mentioned in
the paper but is convenient to have around in the mechanization for
automation purposes.</p></li>
<li><p>Coquand's algorithm (Sec. 4.1)</p>
<p>Coquand's algorithm is one of the exceptions of the above naming
scheme, and the actual formal definition is slightly different from the
text presentation. Notably, the algorithmic equality for head normal
forms is split into two relations, one that handles the case where both
terms are neutral, and one that handles the cases where at least one
term is not neutral.</p>
<ul>
<li>Algorithmic equality (<span
class="math inline"><em>a</em> ↔︎ <em>b</em></span> in the text): <a
href="./html/DecSyn.algorithmic.html#CoqEq_R">CoqEq_R</a> (<span
class="math inline"><em>a</em> ⇔ <em>b</em></span> in the
mechanization)</li>
<li>Algorithmic equality for head normal forms (<span
class="math inline"><em>f</em><sub>0</sub> ∼ <em>f</em><sub>1</sub></span>
in the text):
<ul>
<li>When both inputs are neutral: <a
href="./html/DecSyn.algorithmic.html#CoqEq_Neu">CoqEq_Neu</a> (<span
class="math inline"><em>a</em> ∼ <em>b</em></span> in the
mechanization)</li>
<li>Otherwise: <a href="./html/DecSyn.algorithmic.html#CoqEq">CoqEq</a>
(<span class="math inline"><em>a</em> ↔︎ <em>b</em></span> in the
mechanization)</li>
</ul></li>
</ul>
<p>The relations are all formulated on arbitrary terms. The neutral and
normal form restrictions in <span
class="math inline"><em>f</em><sub>0</sub> ∼ <em>f</em><sub>1</sub></span>
are proven a posteriori as lemmas in the mechanization (e.g. <a
href="./html/DecSyn.executable_correct.html#coqeq_no_hred">coqeq_no_hred</a>).</p>
<p>Subtyping works similarly, though there is no need to split the
relation as the neutral case is handled by equalities.</p>
<ul>
<li>Algorithmic subtyping (<span
class="math inline"><em>A</em> ≪ <em>B</em></span>): <a
href="./html/DecSyn.algorithmic.html#CoqLEq_R">CoqLEq_R</a></li>
<li>Algorithmic subtyping for head normal forms (<span
class="math inline"><em>f</em><sub>0</sub> ≲ <em>f</em><sub>1</sub></span>):
<a href="./html/DecSyn.algorithmic.html#CoqLEq">CoqLEq</a></li>
</ul></li>
</ol>
<h3 id="the-untyped-logical-predicate-sec-3.7">The untyped logical
predicate (Sec 3.7)</h3>
<p>As mentioned in the text, the definition of the logical predicate
cannot be written in Rocq directly as it consists of an inductive
definition nested in a fixpoint definition over universe levels.</p>
<p>The technique we adopt to encode the logical relation is described in
detail in the <a
href="https://www.seas.upenn.edu/~sweirich/papers/liu-mltt-consistency.pdf">write-up</a>
by Liu and Weirich. To make the code more readable, we specify a module
type <a href="./html/DecSyn.logrel.html#LogRel">LogRel</a> that includes
the introduction and induction principles that fully characterizes the
logical predicate. The module <a
href="./html/DecSyn.logrel.html#LogRelImpl">LogRelImpl</a> shows how the
logical predicate is actually defined through the inductive definition
<a href="./html/DecSyn.logrel.html#LogRelImpl.InterpExt">InterpExt</a>
and the fixpoint <a
href="./html/DecSyn.logrel.html#LogRel.InterpUniv">InterpUniv</a>, the
latter of which the logical predicate satisfying the abstract properties
we actually need.</p>
<p>By encapsulating the Rocq-specific workarounds behind the module
signature, the properties about the logical predicate (found in <a
href="./html/DecSyn.logrel.html#LogRelFactsImpl">LogRelFactsImpl</a>)
can be implemented purely in terms of the clean interface specified in
<a href="./html/DecSyn.logrel.html#LogRel">LogRel</a>.</p>
<ul>
<li>logical predicate (<span
class="math inline">⟦<em>A</em>⟧ ↘ <em>S</em></span>): InterpUniv (<a
href="./html/DecSyn.logrel.html#LogRel.InterpUniv">signature</a>, <a
href="./html/DecSyn.logrel.html#LogRelImpl.InterpUniv">implementation</a>)
<ul>
<li>induction principle (<a
href="./html/DecSyn.logrel.html#LogRel.InterpUniv_ind">signature</a>, <a
href="./html/DecSyn.logrel.html#LogRelImpl.InterpUniv_ind">implementation</a>)</li>
<li>introduction rules (omitted, defined in the same module)</li>
</ul></li>
</ul>
<p>To avoid introducing propositional and functional extensionality
axioms, we add rule <a
href="./html/DecSyn.logrel.html#LogRel.InterpUniv_Conv">InterpUniv_Conv</a>
to our mechanization to ensure that the logical predicate operates on
predicates that are extensionally equivalent (denoted by <span
class="math inline">≐</span> in the mechanization). These artifacts
introduced by avoiding the axioms are noted in the development and can
be safely ignored.</p>
<h3 id="executable-conversion-algorithm-sec.-4">Executable conversion
algorithm (Sec. 4)</h3>
<p>The relational definition of algorithmic conversion is not
immediately executable. The decidability result (Theorem 4.1) is
justified by defining a total function that returns true precisely when
two of its input are convertible.</p>
<p>Here, we give links to the definition of the algorithm and the
Bove-Capretta domains to handle termination checking.</p>
<ul>
<li>Executable algorithmic
<ul>
<li>subtyping: <a
href="./html/DecSyn.executable.html#check_sub_r">check_sub_r</a></li>
<li>equality: <a
href="./html/DecSyn.executable.html#check_equal_r">check_equal_r</a></li>
</ul></li>
<li>Bove-Capretta domains for
<ul>
<li>subtyping: <a
href="./html/DecSyn.common.html#salgo_dom_r">salgo_dom_r</a></li>
<li>equality: <a
href="./html/DecSyn.common.html#algo_dom_r">algo_dom_r</a></li>
</ul></li>
</ul>
<p>The completeness and soundness of the computable functions with
respect to their relational counterparts are not explicitly included in
the paper, but they are linked in the mechanization by the following
lemmas.</p>
<ul>
<li>subtyping: <a
href="./html/DecSyn.executable_correct.html#check_sub_sound">check_sub_sound</a>,
<a
href="./html/DecSyn.executable_correct.html#check_sub_complete">check_sub_complete</a></li>
<li>equality: <a
href="./html/DecSyn.executable_correct.html#check_eq_sound">check_eq_sound</a>,
<a
href="./html/DecSyn.executable_correct.html#check_eq_complete">check_eq_complete</a></li>
</ul>
<p>The termination of algorithmic conversion is implied by the above
completeness and soundness results.</p>
<h2 id="properties-proven-in-the-paper">Properties proven in the
paper</h2>
<h3 id="section-2">Section 2</h3>
<dl>
<dt>Lemma 2.1 (context regularity)</dt>
<dd>
<a href="./html/DecSyn.structural.html#wff_mutual">wff_mutual</a>
</dd>
<dt>Lemma 2.2 (inversion)</dt>
<dd>
<a href="./html/DecSyn.structural.html#Bind_Inv">Bind_Inv</a>, <a
href="./html/DecSyn.structural.html#Var_Inv">Var_Inv</a>, <a
href="./html/DecSyn.admissible.html#App_Inv">App_Inv</a>, <a
href="./html/DecSyn.admissible.html#Abs_Inv">Abs_Inv</a>, <a
href="./html/DecSyn.admissible.html#Proj1_Inv">Proj1_Inv</a>, <a
href="./html/DecSyn.admissible.html#Proj2_Inv">Proj2_Inv</a>, <a
href="./html/DecSyn.admissible.html#Pair_Inv">Pair_Inv</a>
</dd>
<dt>Lemma 2.3 (subject reduction)</dt>
<dd>
<a
href="./html/DecSyn.preservation.html#subject_reduction">subject_reduction</a>
</dd>
<dt>Lemma 2.4 (type correctness)</dt>
<dd>
<a href="./html/DecSyn.structural.html#regularity">regularity</a>
</dd>
</dl>
<h3 id="section-3">Section 3</h3>
<dl>
<dt>Lemma 3.1</dt>
<dd>
<a href="./html/DecSyn.fp_red.html#RRed.nf_imp">RRed.nf_imp</a>
</dd>
<dt>Lemma 3.2</dt>
<dd>
<a
href="./html/DecSyn.fp_red.html#ERed.nf_preservation">ERed.nf_preservation</a>
</dd>
<dt>Lemma 3.3</dt>
<dd>
<a
href="./html/DecSyn.fp_red.html#LoReds.FromSN_mutual">LoReds.FromSN_mutual</a>
</dd>
<dt>Lemma 3.4 (no stuck terms)</dt>
<dd>
<a
href="./html/DecSyn.fp_red.html#SN_NoForbid.PApp_imp">SN_NoForbid.PApp_imp</a>,
<a
href="./html/DecSyn.fp_red.html#SN_NoForbid.PProj_imp">SN_NoForbid.PProj_imp</a>,
<a
href="./html/DecSyn.fp_red.html#SN_NoForbid.PInd_imp">SN_NoForbid.PInd_imp</a>
(the <span class="math inline"><em>P</em></span> property is defined as
<span class="math inline"><em>S</em><em>N</em></span>)
</dd>
<dt>Lemma 3.5 (SN renaming)</dt>
<dd>
<a href="./html/DecSyn.fp_red.html#sn_renaming">sn_renaming</a>
</dd>
<dt>Lemma 3.6 (SN antisubstitution)</dt>
<dd>
<a href="./html/DecSyn.fp_red.html#sn_unmorphing">sn_unmorphing</a>
</dd>
<dt>Lemma 3.7 (SN inversion)</dt>
<dd>
<a href="./html/DecSyn.fp_red.html#P_AppInv">P_AppInv</a>, <a
href="./html/DecSyn.fp_red.html#P_PairInv">P_PairInv</a>, <a
href="./html/DecSyn.fp_red.html#P_ProjInv">P_ProjInv</a>, <a
href="./html/DecSyn.fp_red.html#P_BindInv">P_BindInv</a>, <a
href="./html/DecSyn.fp_red.html#P_SucInv">P_SucInv</a>, <a
href="./html/DecSyn.fp_red.html#P_AbsInv">P_AbsInv</a>, <a
href="./html/DecSyn.fp_red.html#P_IndInv">P_IndInv</a>
</dd>
<dt>Lemma 3.8 (sn preservation)</dt>
<dd>
<p>split into two separate lemmas</p>
<dl>
<dt>preservation for parallel <span
class="math inline"><em>η</em></span>-reduction</dt>
<dd>
<a
href="./html/DecSyn.fp_red.html#epar_sn_preservation">epar_sn_preservation</a>
</dd>
<dt>preservation for parallel <span
class="math inline"><em>β</em></span>-reduction</dt>
<dd>
<a
href="./html/DecSyn.fp_red.html#red_sn_preservation">red_sn_preservation</a>
</dd>
</dl>
</dd>
<dt>Lemma 3.9 (restrictive-<span class="math inline"><em>η</em></span>
and normal form)</dt>
<dd>
<a
href="./html/DecSyn.fp_red.html#NeEPar.R_elim_nf">NeEPar.R_elim_nf</a>
</dd>
<dt>Lemma 3.10 (<span
class="math inline"><em>η</em></span>-decomposition)</dt>
<dd>
<a
href="./html/DecSyn.fp_red.html#UniqueNF.η_split">UniqueNF.η_split</a>
</dd>
<dt>Lemma 3.11 (<span
class="math inline"><em>η</em></span>-postponement)</dt>
<dd>
<a
href="./html/DecSyn.fp_red.html#UniqueNF.η_postponement">UniqueNF.η_postponement</a>
</dd>
<dt>Corollary 3.1 (strengthened <span
class="math inline"><em>η</em></span>-postponement)</dt>
<dd>
<a
href="./html/DecSyn.fp_red.html#UniqueNF.η_postponement_strengthened">UniqueNF.η_postponement_strengthened</a>
</dd>
<dt>Corollary 3.2 (<span
class="math inline"><em>η</em></span>-postponement for normal
forms)</dt>
<dd>
<a
href="./html/DecSyn.fp_red.html#rered_standardization&#39;">rered_standardization'</a>
</dd>
<dt>Lemma 3.12 (confluence for <span
class="math inline"><em>β</em></span>)</dt>
<dd>
<a href="./html/DecSyn.fp_red.html#red_confluence">red_confluence</a>
</dd>
<dt>Lemma 3.13 (confluence for <span
class="math inline"><em>η</em></span>)</dt>
<dd>
<a href="./html/DecSyn.fp_red.html#ered_confluence">ered_confluence</a>
</dd>
<dt>Theorem 3.1 (confluence for <span
class="math inline"><em>β</em><em>η</em></span></dt>
<dd>
<a
href="./html/DecSyn.fp_red.html#rered_confluence">rered_confluence</a>
</dd>
<dt>Lemma 3.14 (transitivity of joinability)</dt>
<dd>
<a
href="./html/DecSyn.fp_red.html#DJoin.transitive">DJoin.transitive</a>
</dd>
<dt>Lemma 3.15 (injectivity of joinability)</dt>
<dd>
<a
href="./html/DecSyn.fp_red.html#DJoin.hne_app_inj">DJoin.hne_app_inj</a>,
<a
href="./html/DecSyn.fp_red.html#DJoin.hne_proj_inj">DJoin.hne_proj_inj</a>
</dd>
<dt>Lemma 3.16 (transitivity of one-step subtyping)</dt>
<dd>
<a href="./html/DecSyn.fp_red.html#Sub1.transitive">Sub1.transitive</a>
</dd>
<dt>Lemma 3.17 (commutativity of one-step subtyping)</dt>
<dd>
<a
href="./html/DecSyn.fp_red.html#Sub1.commutativity0">Sub1.commutativity0</a>
</dd>
<dt>Lemma 3.18 (one-step subtyping preserves sn)</dt>
<dd>
<a
href="./html/DecSyn.fp_red.html#Sub1.sn_preservation">Sub1.sn_preservation</a>
</dd>
<dt>Corollary 3.3 (transitivity of untyped subtyping)</dt>
<dd>
<a href="./html/DecSyn.fp_red.html#Sub.transitive">Sub.transitive</a>
</dd>
<dt>Lemma 3.19 (noconfusion for untyped subtyping)</dt>
<dd>
The Sub.*_noconf lemmas starting with <a
href="./html/DecSyn.fp_red.html#Sub.sne_nat_noconf">Sub.sne_nat_noconf</a>
</dd>
<dt>Lemma 3.20 (untyped injectivity of type constructors)</dt>
<dd>
<a href="./html/DecSyn.fp_red.html#Sub.bind_inj">Sub.bind_inj</a>, <a
href="./html/DecSyn.fp_red.html#Sub.univ_inj">Sub.univ_inj</a>
</dd>
<dt>Lemma 3.21 (adequacy)</dt>
<dd>
<a
href="./html/DecSyn.logrel.html#LogRelFactsImpl.adequacy">LogRelFactsImpl.adequacy</a>
</dd>
<dt>Lemma 3.22 (backward closure)</dt>
<dd>
<a
href="./html/DecSyn.logrel.html#LogRelFactsImpl.back_clos">LogRelFactsImpl.back_clos</a>
</dd>
<dt>Lemma 3.23 (logical predicate cases)</dt>
<dd>
<a
href="./html/DecSyn.logrel.html#LogRelFactsImpl.case">LogRelFactsImpl.case</a>
</dd>
<dt>Lemma 3.24 (logical predicate is preserved by subtyping)</dt>
<dd>

</dd>
</dl>
<p><a
href="./html/DecSyn.logrel.html#LogRelFactsImpl.sub">LogRelFactsImpl.sub</a></p>
<dl>
<dt>Corollary 3.4 (logical predicate is functional)</dt>
<dd>
<a
href="./html/DecSyn.logrel.html#LogRelFactsImpl.functional">LogRelFactsImpl.functional</a>
</dd>
<dt>Lemma 3.25 (logical predicate is cumulative)</dt>
<dd>
<a
href="./html/DecSyn.logrel.html#LogRelFactsImpl.cumulative">LogRelFactsImpl.cumulative</a>
</dd>
<dt>Lemma 3.26 (semantic weakening)</dt>
<dd>
<a href="./html/DecSyn.logrel.html#weakening_Sem">weakening_Sem</a>
</dd>
<dt>Lemma 3.27 (semantic substitution)</dt>
<dd>
<a href="./html/DecSyn.logrel.html#morphing_SemWt">morphing_SemWt</a>
</dd>
<dt>Lemma 3.28 (structural rules for semantic well-formedness)</dt>
<dd>
<a href="./html/DecSyn.logrel.html#SemWff_lookup">SemWff_lookup</a>
</dd>
<dt>Theorem 3.2 (fundamental theorem)</dt>
<dd>
<a
href="./html/DecSyn.soundness.html#fundamental_theorem">fundamental_theorem</a>
</dd>
<dt>Corollary 3.5 (completeness of reduce-and-compare)</dt>
<dd>
Inlined into proof scripts
</dd>
<dt>Corollary 3.6 (completeness of reduce-and-compare)</dt>
<dd>
<a
href="./html/DecSyn.soundness.v.html#synsub_to_usub">synsub_to_usub</a>
</dd>
</dl>
<h3 id="section-4">Section 4</h3>
<dl>
<dt>Lemma 4.1 (<span
class="math inline"><em>Π</em></span>-subtyping)</dt>
<dd>
<a
href="./html/DecSyn.algorithmic.html#Sub_Bind_InvL">Sub_Bind_InvL</a>,
<a href="./html/DecSyn.algorithmic.html#Sub_Bind_InvR">Sub_Bind_InvR</a>
</dd>
<dt>Lemma 4.2 (univ-subtyping)</dt>
<dd>
<a href="./html/DecSyn.algorithmic.html#Sub_Univ_InvR">Sub_Univ_InvR</a>
</dd>
<dt>Lemma 4.3 (soundness for algorithmic equality)</dt>
<dd>
<a
href="./html/DecSyn.algorithmic.html#coqeq_sound_mutual">coqeq_sound_mutual</a>
</dd>
<dt>Lemma 4.4 (soundness for algorithmic subtyping)</dt>
<dd>
<a
href="./html/DecSyn.algorithmic.html#coqleq_sound_mutual">coqleq_sound_mutual</a>
</dd>
<dt>Lemma 4.5 (metric implies domain)</dt>
<dd>
<a
href="./html/DecSyn.algorithmic.html#sn_term_metric">sn_term_metric</a>
</dd>
<dt>Lemma 4.6 (termination of Coquand's algorithm)</dt>
<dd>
<a href="./html/DecSyn.executable.html#check_sub">check_sub</a>
(termination is implicit in our mechanization in the sense that we can
construct the Bove-Capretta domain from the typing judgment, which we
can then feed to the <code class="verbatim">check_sub</code> function)
</dd>
<dt>Lemma 4.7 (completeness of Coquand's algorithm)</dt>
<dd>
<a
href="./html/DecSyn.algorithmic.html#coqeq_complete&#39;">coqeq_complete'</a>
</dd>
<dt>Lemma 4.8 (completeness of Coquand's algorithmic subtyping)</dt>
<dd>

</dd>
</dl>
<p><a
href="./html/DecSyn.algorithmic.html#coqleq_complete&#39;">coqleq_complete'</a></p>
<dl>
<dt>Lemma 4.9 (completeness of Coquand's algorithmic subtyping)</dt>
<dd>

</dd>
</dl>
<p><a
href="./html/DecSyn.algorithmic.html#coqleq_complete_unty">coqleq_complete_unty</a>,
<a
href="./html/DecSyn.algorithmic.html#coqleq_complete">coqleq_complete</a>,
<a
href="./html/DecSyn.algorithmic.html#coqleq_sound">coqleq_sound</a></p>
<dl>
<dt>Theorem 4.1</dt>
<dd>
by composing 4.9 and 4.6
</dd>
</dl>
<h3 id="section-5">Section 5</h3>
<dl>
<dt>Proposition 5.1</dt>
<dd>
<a href="./html/DecSyn.cosn.html#Safe_NoForbid">Safe_NoForbid</a>
</dd>
</dl>
<h2 id="validating-axiom-usage">Validating axiom usage</h2>
<p>We claim that our development is axiom-free. To validate that claim,
one can use the <code class="verbatim">Print Assumptions</code> command
on the theorems and confirm that no axioms are displayed.</p>
<p>An alternative method is to run <code class="verbatim">coqchk</code>,
which can be invoked on all <code class="verbatim">.vo</code> files by
running <code class="verbatim">make validate</code>. However, <code
class="verbatim">coqchk</code> doesn't work that well with module types
and will report axioms that we didn't actually use in the
development.</p>
<div class="sourceCode" id="cb4" data-org-language="sh"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">*</span> Theory: Set is predicative</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="ex">*</span> Theory: Rewrite rules are not allowed</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="ex">*</span> Axioms:</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="ex">DecSyn.logrel.LRFacts.functional</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="ex">DecSyn.logrel.LRFacts.Bind_inv_nopf</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="ex">DecSyn.logrel.LRFacts.back_clos</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="ex">DecSyn.logrel.LRFacts.Bind_nopf</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="ex">DecSyn.logrel.LRFacts.adequacy</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="ex">DecSyn.logrel.LRFacts.back_closs</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Coq.Logic.FunctionalExtensionality.functional_extensionality_dep</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Coq.Reals.ClassicalDedekindReals.sig_not_dec</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="ex">DecSyn.logrel.LRFacts.join</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="ex">DecSyn.logrel.LRFacts.case</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="ex">DecSyn.logrel.LRFacts.sub</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Coq.Reals.ClassicalDedekindReals.sig_forall_dec</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="ex">DecSyn.logrel.LRFacts.cumulative</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="ex">DecSyn.logrel.LRFacts.Univ_inv</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="ex">DecSyn.logrel.LRFacts.SNe_inv</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="ex">DecSyn.logrel.LRFacts.Bind_inv</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Coq.Logic.Eqdep.Eq_rect_eq.eq_rect_eq</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="ex">DecSyn.fp_red.NoForbid_FactSN.P_RReds</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="ex">DecSyn.fp_red.NoForbid_FactSN.P_EPars</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="ex">DecSyn.logrel.LRFacts.Nat_inv</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="ex">*</span> Constants/Inductives relying on type-in-type: <span class="op">&lt;</span>none<span class="op">&gt;</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a><span class="ex">*</span> Constants/Inductives relying on unsafe <span class="er">(</span><span class="fu">co</span><span class="kw">)</span><span class="ex">fixpoints:</span> <span class="op">&lt;</span>none<span class="op">&gt;</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a><span class="ex">*</span> Inductives whose positivity is assumed: <span class="op">&lt;</span>none<span class="op">&gt;</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a><span class="va">make</span><span class="op">[</span><span class="dv">1</span><span class="op">]</span><span class="ex">:</span> Leaving directory <span class="st">&#39;****&#39;</span></span></code></pre></div>
<p>Again, all the axiom reported are false positives and you should
always trust <code class="verbatim">Print Assumptions</code> when it
comes to axiom usage. Still, the output provides the useful information
that our development does not rely on any of the dangerous or
inconsistent features that would make our theorems trivially true.</p>
</body>
</html>
